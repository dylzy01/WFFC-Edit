// Setup a ray trace from given position
Ray Game::Trace(Vector2 position)
{
	// Setup ray trace origin
	Vector3 origin = XMVector3Unproject(Vector3(position.x, position.y, 0.f),
		0,
		0,
		m_deviceResources->GetScreenViewport().Width,
		m_deviceResources->GetScreenViewport().Height,
		0,
		1,
		m_projection,
		m_view,
		m_world);

	// Setup ray trace destination
	Vector3 destination = XMVector3Unproject(Vector3(position.x, position.y, 1.f),
		0,
		0,
		m_deviceResources->GetScreenViewport().Width,
		m_deviceResources->GetScreenViewport().Height,
		0,
		1,
		m_projection,
		m_view,
		m_world);

	// Setup ray trace direction
	Vector3 direction = destination - origin;
	direction.Normalize();

	// Return ray trace
	return Ray(origin, direction);
}




// If mouse has been dragged
								if (dragged)
								{
									// Temp storage 
									Vector2 previous = m_inputCommands.mousePosPrevious;
									Vector2 current = m_inputCommands.mousePos;
									Vector3 object = m_displayList[m_selectedObjectIDs[i]].m_position;

									// Get distance between the two 
									//float distance = sqrt(
									//	(current.x - previous.x) * (current.x - previous.x) +
									//	(current.y - previous.y) * (current.y - previous.y));
									//
									//// Scale selected object based on distance
									//m_displayList[m_selectedObjectIDs[i]].m_scale.x += distance;

									// Setup previous & current ray traces
									Ray pre = Trace(previous);
									Ray cur = Trace(current);

									// Distance between previous & object
									float distP = sqrt(
										(pre.position.x - object.x) * (pre.position.x - object.x) +
										(pre.position.y - object.y) * (pre.position.y - object.y) +
										(pre.position.z - object.z) * (pre.position.z - object.z));

									// Distance between current & object
									float distC = sqrt(
										(cur.position.x - object.x) * (cur.position.x - object.x) +
										(cur.position.y - object.y) * (cur.position.y - object.y) +
										(cur.position.z - object.z) * (cur.position.z - object.z));

									// Setup temp picking points
									Vector3 pickingP = pre.position + (pre.direction * distP);
									Vector3 pickingC = cur.position + (cur.direction * distC);

									// Distance between both picking points
									float distance = sqrt(
										(pickingC.x - pickingP.x) * (pickingC.x - pickingP.x) +
										(pickingC.y - pickingP.y) * (pickingC.y - pickingP.y) +
										(pickingC.z - pickingP.z) * (pickingC.z - pickingP.z));

									// Alter object scale based on picking points distance
									m_displayList[m_selectedObjectIDs[i]].m_scale.x += distance;
								}